Terminals unused in grammar

    SEMICOLON
    CLASS
    ELSE
    FI
    IF
    IN
    INHERITS
    LET
    LOOP
    POOL
    THEN
    WHILE
    CASE
    ESAC
    OF
    DARROW
    NEW
    ISVOID
    STR_CONST
    BOOL_CONST
    TYPEID
    IDENTIFIER
    NOT
    LE
    LET_STMT
    ASSIGN
    ERROR


State 1 conflicts: 4 shift/reduce
State 15 conflicts: 4 shift/reduce


Grammar

    0 $accept: prog $end

    1 prog: E

    2 E: INT_CONST
    3  | INT_CONST OP INT_CONST
    4  | LBRACE E RBRACE
    5  | E OP E

    6 OP: PLUS
    7   | MINUS
    8   | DIVIDE
    9   | MULTIPLY


Terminals, with rules where they appear

    $end (0) 0
    error (256)
    SEMICOLON (258)
    CLASS (259)
    ELSE (260)
    FI (261)
    IF (262)
    IN (263)
    INHERITS (264)
    LET (265)
    LOOP (266)
    POOL (267)
    THEN (268)
    WHILE (269)
    CASE (270)
    ESAC (271)
    OF (272)
    DARROW (273)
    NEW (274)
    ISVOID (275)
    STR_CONST <string> (276)
    INT_CONST (277) 2 3
    BOOL_CONST (278)
    TYPEID (279)
    IDENTIFIER (280)
    NOT (281)
    LE (282)
    LET_STMT (283)
    ASSIGN (284)
    PLUS (285) 6
    MINUS (286) 7
    MULTIPLY (287) 9
    DIVIDE (288) 8
    LBRACE (289) 4
    RBRACE (290) 4
    ERROR (291)


Nonterminals, with rules where they appear

    $accept (37)
        on left: 0
    prog (38)
        on left: 1
        on right: 0
    E (39)
        on left: 2 3 4 5
        on right: 1 4 5
    OP (40)
        on left: 6 7 8 9
        on right: 3 5


State 0

    0 $accept: . prog $end

    INT_CONST  shift, and go to state 1
    LBRACE     shift, and go to state 2

    prog  go to state 3
    E     go to state 4


State 1

    2 E: INT_CONST .
    3  | INT_CONST . OP INT_CONST

    PLUS      shift, and go to state 5
    MINUS     shift, and go to state 6
    MULTIPLY  shift, and go to state 7
    DIVIDE    shift, and go to state 8

    PLUS      [reduce using rule 2 (E)]
    MINUS     [reduce using rule 2 (E)]
    MULTIPLY  [reduce using rule 2 (E)]
    DIVIDE    [reduce using rule 2 (E)]
    $default  reduce using rule 2 (E)

    OP  go to state 9


State 2

    4 E: LBRACE . E RBRACE

    INT_CONST  shift, and go to state 1
    LBRACE     shift, and go to state 2

    E  go to state 10


State 3

    0 $accept: prog . $end

    $end  shift, and go to state 11


State 4

    1 prog: E .
    5 E: E . OP E

    PLUS      shift, and go to state 5
    MINUS     shift, and go to state 6
    MULTIPLY  shift, and go to state 7
    DIVIDE    shift, and go to state 8

    $default  reduce using rule 1 (prog)

    OP  go to state 12


State 5

    6 OP: PLUS .

    $default  reduce using rule 6 (OP)


State 6

    7 OP: MINUS .

    $default  reduce using rule 7 (OP)


State 7

    9 OP: MULTIPLY .

    $default  reduce using rule 9 (OP)


State 8

    8 OP: DIVIDE .

    $default  reduce using rule 8 (OP)


State 9

    3 E: INT_CONST OP . INT_CONST

    INT_CONST  shift, and go to state 13


State 10

    4 E: LBRACE E . RBRACE
    5  | E . OP E

    PLUS      shift, and go to state 5
    MINUS     shift, and go to state 6
    MULTIPLY  shift, and go to state 7
    DIVIDE    shift, and go to state 8
    RBRACE    shift, and go to state 14

    OP  go to state 12


State 11

    0 $accept: prog $end .

    $default  accept


State 12

    5 E: E OP . E

    INT_CONST  shift, and go to state 1
    LBRACE     shift, and go to state 2

    E  go to state 15


State 13

    3 E: INT_CONST OP INT_CONST .

    $default  reduce using rule 3 (E)


State 14

    4 E: LBRACE E RBRACE .

    $default  reduce using rule 4 (E)


State 15

    5 E: E . OP E
    5  | E OP E .

    PLUS      shift, and go to state 5
    MINUS     shift, and go to state 6
    MULTIPLY  shift, and go to state 7
    DIVIDE    shift, and go to state 8

    PLUS      [reduce using rule 5 (E)]
    MINUS     [reduce using rule 5 (E)]
    MULTIPLY  [reduce using rule 5 (E)]
    DIVIDE    [reduce using rule 5 (E)]
    $default  reduce using rule 5 (E)

    OP  go to state 12
